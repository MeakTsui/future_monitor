<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Market State - TradingView Lightweight Charts</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 {
      color: #333;
      margin-bottom: 20px;
      font-size: 24px;
    }
    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .controls label {
      margin-right: 10px;
      font-weight: 500;
    }
    .controls select, .controls button {
      padding: 8px 16px;
      border-radius: 6px;
      border: 1px solid #ddd;
      margin-right: 10px;
      font-size: 14px;
      cursor: pointer;
    }
    .controls button {
      background: #2196F3;
      color: white;
      border: none;
    }
    .controls button:hover {
      background: #1976D2;
    }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .chart-wrapper {
      position: relative;
      height: 400px;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .stat-card h3 {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }
    .stat-card .value {
      font-size: 28px;
      font-weight: bold;
      color: #333;
    }
    .stat-card .value.positive {
      color: #4CAF50;
    }
    .stat-card .value.negative {
      color: #F44336;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    .error {
      background: #ffebee;
      color: #c62828;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ“Š Market State Monitor - æ•°æ®å¯è§†åŒ–</h1>
    
    <div class="controls">
      <label>æ—¶é—´èŒƒå›´:</label>
      <select id="timeRange">
        <option value="1">æœ€è¿‘1å°æ—¶</option>
        <option value="6">æœ€è¿‘6å°æ—¶</option>
        <option value="24" selected>æœ€è¿‘24å°æ—¶</option>
        <option value="72">æœ€è¿‘3å¤©</option>
        <option value="168">æœ€è¿‘7å¤©</option>
      </select>
      
      <label>åˆ†è¾¨ç‡:</label>
      <select id="resolution">
        <option value="1">1åˆ†é’Ÿ</option>
        <option value="5" selected>5åˆ†é’Ÿ</option>
        <option value="15">15åˆ†é’Ÿ</option>
        <option value="60">1å°æ—¶</option>
      </select>
      
      <button onclick="loadData()">ğŸ”„ åˆ·æ–°æ•°æ®</button>
      <button onclick="toggleAutoRefresh()">â±ï¸ <span id="autoRefreshText">å¯ç”¨è‡ªåŠ¨åˆ·æ–°</span></button>
    </div>

    <div id="error" class="error" style="display: none;"></div>

    <div class="stats">
      <div class="stat-card">
        <h3>å½“å‰ä»·æ ¼å¾—åˆ†</h3>
        <div class="value" id="currentPrice">--</div>
      </div>
      <div class="stat-card">
        <h3>å½“å‰æˆäº¤é‡å¾—åˆ†</h3>
        <div class="value" id="currentVolume">--</div>
      </div>
      <div class="stat-card">
        <h3>æ•°æ®ç‚¹æ•°é‡</h3>
        <div class="value" id="dataPoints">--</div>
      </div>
      <div class="stat-card">
        <h3>æœ€åæ›´æ–°</h3>
        <div class="value" style="font-size: 16px;" id="lastUpdate">--</div>
      </div>
    </div>

    <div class="chart-container">
      <h2 style="margin-bottom: 15px; font-size: 18px;">Market Price Score (-100 ~ 100)</h2>
      <div class="chart-wrapper">
        <canvas id="priceChart"></canvas>
      </div>
    </div>

    <div class="chart-container">
      <h2 style="margin-bottom: 15px; font-size: 18px;">Market Volume Score (0 ~ 100)</h2>
      <div class="chart-wrapper">
        <canvas id="volumeChart"></canvas>
      </div>
    </div>
  </div>

  <script>
    const SERVER_URL = 'http://localhost:8080';
    let priceChart = null;
    let priceSeries = null;
    let volumeChart = null;
    let volumeSeries = null;
    let autoRefreshInterval = null;

    // æ˜¾ç¤ºé”™è¯¯
    function showError(message) {
      const errorEl = document.getElementById('error');
      if (errorEl) {
        errorEl.textContent = 'âŒ ' + message;
        errorEl.style.display = 'block';
      }
      console.error('Error:', message);
    }

    function hideError() {
      document.getElementById('error').style.display = 'none';
    }

    // åˆå§‹åŒ– TradingView å›¾è¡¨
    function initCharts() {
      try {
        console.log('åˆå§‹åŒ– TradingView å›¾è¡¨...');
        
        if (typeof LightweightCharts === 'undefined') {
          throw new Error('TradingView Lightweight Charts æœªåŠ è½½');
        }
        console.log('âœ“ TradingView Lightweight Charts å·²åŠ è½½');
        
        const commonOptions = {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                title: (items) => {
                  const date = new Date(items[0].parsed.x);
                  return date.toLocaleString('zh-CN');
                }
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                displayFormats: {
                  minute: 'HH:mm',
                  hour: 'MM-DD HH:mm',
                  day: 'MM-DD'
                }
              },
              grid: {
                display: false
              }
            },
            y: {
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            }
          }
        };

        // Price Chart
        console.log('åˆ›å»º Price Chart...');
        const priceCanvas = document.getElementById('priceChart');
        if (!priceCanvas) {
          throw new Error('æ‰¾ä¸åˆ° priceChart canvas å…ƒç´ ');
        }
        console.log('priceChart canvas å…ƒç´ æ‰¾åˆ°');
        
        const priceCtx = priceCanvas.getContext('2d');
        if (!priceCtx) {
          throw new Error('æ— æ³•è·å– priceChart 2D ä¸Šä¸‹æ–‡');
        }
        
        priceChart = new Chart(priceCtx, {
          type: 'line',
          data: {
            datasets: [{
              label: 'Price Score',
              data: [],
              borderColor: 'rgb(33, 150, 243)',
              backgroundColor: 'rgba(33, 150, 243, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            ...commonOptions,
            scales: {
              ...commonOptions.scales,
              y: {
                ...commonOptions.scales.y,
                min: -100,
                max: 100,
                ticks: {
                  callback: (value) => value.toFixed(0)
                }
              }
            }
          }
        });
        
        if (!priceChart) {
          throw new Error('Price Chart åˆ›å»ºå¤±è´¥');
        }
        console.log('Price Chart åˆ›å»ºæˆåŠŸ');

        // Volume Chart
        console.log('åˆ›å»º Volume Chart...');
        const volumeCanvas = document.getElementById('volumeChart');
        if (!volumeCanvas) {
          throw new Error('æ‰¾ä¸åˆ° volumeChart canvas å…ƒç´ ');
        }
        console.log('volumeChart canvas å…ƒç´ æ‰¾åˆ°');
        
        const volumeCtx = volumeCanvas.getContext('2d');
        if (!volumeCtx) {
          throw new Error('æ— æ³•è·å– volumeChart 2D ä¸Šä¸‹æ–‡');
        }
        
        volumeChart = new Chart(volumeCtx, {
          type: 'line',
          data: {
            datasets: [{
              label: 'Volume Score',
              data: [],
              borderColor: 'rgb(76, 175, 80)',
              backgroundColor: 'rgba(76, 175, 80, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            ...commonOptions,
            scales: {
              ...commonOptions.scales,
              y: {
                ...commonOptions.scales.y,
                min: 0,
                max: 100,
                ticks: {
                  callback: (value) => value.toFixed(0)
                }
              }
            }
          }
        });
        
        if (!volumeChart) {
          throw new Error('Volume Chart åˆ›å»ºå¤±è´¥');
        }
        console.log('Volume Chart åˆ›å»ºæˆåŠŸ');
        
        console.log('âœ“ æ‰€æœ‰å›¾è¡¨åˆå§‹åŒ–æˆåŠŸ', { priceChart: !!priceChart, volumeChart: !!volumeChart });
      } catch (err) {
        console.error('âœ— å›¾è¡¨åˆå§‹åŒ–å¤±è´¥:', err);
        showError('å›¾è¡¨åˆå§‹åŒ–å¤±è´¥: ' + err.message);
        // ç¡®ä¿å˜é‡è¢«é‡ç½®
        priceChart = null;
        volumeChart = null;
      }
    }

    // åŠ è½½æ•°æ®
    async function loadData() {
      const timeRange = parseInt(document.getElementById('timeRange').value);
      const resolution = document.getElementById('resolution').value;
      
      const to = Math.floor(Date.now() / 1000);
      const from = to - (timeRange * 3600);

      try {
        document.getElementById('error').style.display = 'none';
        
        // ä½¿ç”¨ TradingView history æ¥å£
        const priceUrl = `${SERVER_URL}/tradingview/history?symbol=MARKET_PRICE&resolution=${resolution}&from=${from}&to=${to}`;
        const volumeUrl = `${SERVER_URL}/tradingview/history?symbol=MARKET_VOLUME&resolution=${resolution}&from=${from}&to=${to}`;

        const [priceRes, volumeRes] = await Promise.all([
          fetch(priceUrl),
          fetch(volumeUrl)
        ]);

        const priceData = await priceRes.json();
        const volumeData = await volumeRes.json();

        if (priceData.s === 'ok' && volumeData.s === 'ok') {
          updateCharts(priceData, volumeData);
          updateStats(priceData, volumeData);
        } else {
          showError('æ— æ•°æ®æˆ–æ•°æ®åŠ è½½å¤±è´¥');
        }
      } catch (err) {
        showError('åŠ è½½æ•°æ®å¤±è´¥: ' + err.message);
      }
    }

    // æ›´æ–°å›¾è¡¨
    function updateCharts(priceData, volumeData) {
      try {
        console.log('æ›´æ–°å›¾è¡¨...', { 
          priceChart: !!priceChart, 
          volumeChart: !!volumeChart,
          priceDataPoints: priceData?.t?.length,
          volumeDataPoints: volumeData?.t?.length
        });
        
        if (!priceChart || !volumeChart) {
          throw new Error('å›¾è¡¨æœªåˆå§‹åŒ–');
        }
        
        if (!priceData?.t || !priceData?.c) {
          throw new Error('ä»·æ ¼æ•°æ®æ ¼å¼é”™è¯¯');
        }
        
        if (!volumeData?.t || !volumeData?.c) {
          throw new Error('æˆäº¤é‡æ•°æ®æ ¼å¼é”™è¯¯');
        }
        
        // Price Chart
        const pricePoints = priceData.t.map((time, i) => ({
          x: time * 1000,
          y: priceData.c[i]
        }));
        priceChart.data.datasets[0].data = pricePoints;
        priceChart.update('none');

        // Volume Chart
        const volumePoints = volumeData.t.map((time, i) => ({
          x: time * 1000,
          y: volumeData.c[i]
        }));
        volumeChart.data.datasets[0].data = volumePoints;
        volumeChart.update('none');
        
        console.log('å›¾è¡¨æ›´æ–°æˆåŠŸ');
      } catch (err) {
        console.error('æ›´æ–°å›¾è¡¨å¤±è´¥:', err);
        showError('æ›´æ–°å›¾è¡¨å¤±è´¥: ' + err.message);
      }
    }

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    function updateStats(priceData, volumeData) {
      const currentPrice = priceData.c[priceData.c.length - 1];
      const currentVolume = volumeData.c[volumeData.c.length - 1];
      
      const priceEl = document.getElementById('currentPrice');
      priceEl.textContent = currentPrice.toFixed(2);
      priceEl.className = 'value ' + (currentPrice > 0 ? 'positive' : currentPrice < 0 ? 'negative' : '');
      
      document.getElementById('currentVolume').textContent = currentVolume.toFixed(2);
      document.getElementById('dataPoints').textContent = priceData.t.length;
      
      const lastTime = new Date(priceData.t[priceData.t.length - 1] * 1000);
      document.getElementById('lastUpdate').textContent = lastTime.toLocaleString('zh-CN');
    }

    // è‡ªåŠ¨åˆ·æ–°
    function toggleAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
        document.getElementById('autoRefreshText').textContent = 'å¯ç”¨è‡ªåŠ¨åˆ·æ–°';
      } else {
        autoRefreshInterval = setInterval(loadData, 60000); // æ¯åˆ†é’Ÿåˆ·æ–°
        document.getElementById('autoRefreshText').textContent = 'åœæ­¢è‡ªåŠ¨åˆ·æ–°';
        loadData();
      }
    }

    // åˆå§‹åŒ–
    window.addEventListener('load', () => {
      console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
      try {
        initCharts();
        
        // éªŒè¯å›¾è¡¨æ˜¯å¦åˆå§‹åŒ–æˆåŠŸ
        if (!priceChart || !volumeChart) {
          showError('å›¾è¡¨åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
          console.error('å›¾è¡¨åˆå§‹åŒ–åä»ä¸º null');
          return;
        }
        
        console.log('å›¾è¡¨åˆå§‹åŒ–éªŒè¯é€šè¿‡ï¼Œå¼€å§‹åŠ è½½æ•°æ®');
        loadData();
      } catch (err) {
        console.error('åˆå§‹åŒ–è¿‡ç¨‹å‡ºé”™:', err);
        showError('åˆå§‹åŒ–å¤±è´¥: ' + err.message);
      }
    });
  </script>
</body>
</html>
